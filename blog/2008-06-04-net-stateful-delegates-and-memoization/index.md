---
slug: net-stateful-delegates-and-memoization
title: ".NET Stateful delegates and memoization"
authors: [rogerjohansson]
tags: ["delegates", "lambda", "memoization", "stateful"]
---
Iâ€™ve been planning to write about stateful anonymous delegates for quite some time now so here I go ğŸ™‚

<!-- truncate -->

The common perception of anonymous delegates is that they are stateless functions used for filtering and transformations and similar things.

What is less known is that anonymous delegates can hold state by binding to local variables.  
If you create an anonymous delegate inside a factory method, you can infact give the delegate itâ€™s own state.

**Example:**

```
static Func<int> CreateCounter() 
{
     int i = 0; //bind delegate to a local mutable variable 
     return () => i++; 

     //"i" doesn't really go out of scope here 
     // because it is bound to our delegate 
}
```

By using this method we can now create a stateful delegate:

```
var myCounter = CreateCounter(); 
Console.WriteLine( myCounter() ); //prints : 0 
Console.WriteLine( myCounter() ); //prints : 1 
Console.WriteLine( myCounter() ); //prints : 2
```

The above code will print 1, 2, 3 in the console window, simply because the delegate is increasing the value of the bound variable inside itâ€™s body.

**So where does anonymous delegates store itâ€™s state?**  
The state is stored as fields inside a class that is auto generated by the C# compiler.  
This class will contain the state for all bound variables / arguments that are used inside anonymous delegates defined inside the same method.

**And when is this useful?**  
To be honest, almost never ğŸ˜‰  
But there are cases where it is actually quite nice.

Here is a sample that I came up with after reading Ayendes blog ( [http://www.ayende.com/Blog/archive/2008/06/04/Review-Umbrella-project.aspx](http://www.ayende.com/Blog/archive/2008/06/04/Review-Umbrella-project.aspx) )  
He wrote about â€œmemoizationâ€ and I thought that would make a great example of stateful delegates.

We can create memoizations in C# by exploiting the fact that anonymous delegates bind to local variables.

**Example:**

```
static Func<T1, T2, TResult> CreateMemo
Â Â Â  <T1, T2, TResult>(Func<T1, T2, TResult> source)
{
Â Â Â  var cache = new Dictionary<string, TResult>();
Â Â Â  return (arg1, arg2) =>
Â Â Â Â Â Â Â Â Â Â  {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â  string key = string.Format("{0}|{1}", arg1, arg2);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if (!cache.ContainsKey(key))
Â Â Â Â Â Â Â Â Â Â Â Â Â Â  {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  var value = source(arg1, arg2);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  Console.WriteLine
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ("Returning {0} and adding it to cache", value);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  cache.Add(key, value);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return value;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â  else
Â Â Â Â Â Â Â Â Â Â Â Â Â Â  {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  var value = cache[key];
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  Console.WriteLine
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ("Returning {0} from cache", value);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return value;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â  };Â Â Â Â Â Â Â Â Â Â Â  
}
```

This code will create a memoization for any delegate of the type **Func\<T1, T2, TResult\>.**  
You simply pass a delegate to it, and you will get a memoized delegate back.

The code creates a dictionary that will act as our cache.  
And then returns a new delegate that are bound to this dictionary.  
The returned delegate will transform itâ€™s arguments into a key and then check if the key is present in the cache.  
If the key is present, it will return the cached value.  
And if not, it will call the wrapped delegate and then store the result in the cache.

You can even pass normal methods as argument to the memoizer and get a delegate that acts as a cache around your method.

Well thatâ€™s it ğŸ™‚  
Now go and abuse the mutable variable bindings in your delegates.

Enjoy.

//Roger
